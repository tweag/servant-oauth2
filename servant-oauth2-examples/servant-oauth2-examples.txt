-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Example applications using this library in three ways.
--   
--   Three examples of using this library, either just to demonstrate the
--   end-to-end connection <a>Servant.OAuth2.Examples.Simple</a>, with
--   cookies <a>Servant.OAuth2.Examples.Cookies</a> or with type-level
--   authorisation <a>Servant.OAuth2.Examples.Authorised</a>.
@package servant-oauth2-examples
@version 0.1.0.1

module Servant.OAuth2.Examples.Config
data OAuthConfig
OAuthConfig :: Text -> Text -> Text -> Text -> OAuthConfig
[_name] :: OAuthConfig -> Text
[_id] :: OAuthConfig -> Text
[_secret] :: OAuthConfig -> Text
[_callbackUrl] :: OAuthConfig -> Text
oauthConfigCodec :: TomlCodec OAuthConfig
data Config
Config :: OAuthConfig -> OAuthConfig -> Config
[_githubOAuth] :: Config -> OAuthConfig
[_googleOAuth] :: Config -> OAuthConfig
configCodec :: TomlCodec Config


-- | This is the last example we provide, but also the most interesting,
--   and, indeed, the main motivation for this libraries existence!
--   
--   Here we show how to build type-level authorisation into your Servant
--   API, backed by authentication with OAuth2.
--   
--   We assume you've read over the previous two examples, as we build
--   directly on that knowledge:
--   
--   <ul>
--   <li><a>Servant.OAuth2.Examples.Simple</a></li>
--   <li><a>Servant.OAuth2.Examples.Cookies</a></li>
--   </ul>
module Servant.OAuth2.Examples.Authorisation

-- | This time we're going to have users. We're keeping it light and easy
--   here, so our <i>database</i> is simply a map of emails to users. At
--   this point I'd like to note a slight quirk of oauth2-based
--   authentication.
--   
--   Note that the ident that comes back from the provider is up to that
--   provider itself. So, for example, I could make an entirely new oauth2
--   provider that always returns the same email, for example. In
--   particular, it could always return _you_ email. Then, if this website
--   added my (dodgey) provider to it's list, I would be able to log in as
--   you, if all you to do verify accounts is <i>look up the user by the
--   email</i>. So, in any real system, you should track the <i>provider
--   name</i> along side the user ident, and only use <i>that</i>
--   combination to find users. We don't do that here, but it's worth
--   remembering.
type Db = HashMap Text User

-- | We will use this type to tag particular routes as being only
--   accessible to users with the <a>Admin</a> role, or, alternatively,
--   <i>everyone</i>, i.e. those people having the <a>Anyone</a> role ...
--   namely, everyone!
data Role
Anyone :: Role
Admin :: Role

-- | Our user type that lives in the database. Importantly, this holds the
--   <a>role</a>, which we will check when it comes to verifying if a
--   particular person can access the <a>Admin</a> route.
data User
User :: Text -> Text -> User
[email] :: User -> Text
[role] :: User -> Text

-- | This is a collection of data that we'll want to have available during
--   page processing; so we will wrap the servant <a>Handler</a> type with
--   a <a>ReaderT</a> over this type.
data Env (r :: Role)
Env :: Maybe User -> OAuth2Settings PageM Github OAuth2Result -> OAuthConfig -> OAuth2Settings PageM Google OAuth2Result -> OAuthConfig -> Env (r :: Role)
[user] :: Env (r :: Role) -> Maybe User
[githubSettings] :: Env (r :: Role) -> OAuth2Settings PageM Github OAuth2Result
[githubOAuthConfig] :: Env (r :: Role) -> OAuthConfig
[googleSettings] :: Env (r :: Role) -> OAuth2Settings PageM Google OAuth2Result
[googleOAuthConfig] :: Env (r :: Role) -> OAuthConfig

-- | Our type-level authorisation system. We tag two kinds of <i>page
--   monads</i>; one that works for <a>Anyone</a>; this one.
type PageM = ReaderT (Env 'Anyone) Handler

-- | And this one, that is specialised to <a>Admin</a> users. If we make a
--   mistake, we will get a type error along the lines of <tt>Cannot match
--   'Admin with 'Anyone</tt>.
type AdminPageM = ReaderT (Env 'Admin) Handler

-- | As in the <a>Servant.OAuth2.Examples.Cookies</a> example, our result
--   type is just a redirection with a cookie.
type OAuth2Result = '[WithStatus 303 RedirectWithCookie]

-- | This is almost identical to the <a>Servant.OAuth2.Examples.Cookies</a>
--   example, except we look up the user in the database, and if we find
--   it, we return it.
optionalUserAuthHandler :: Db -> Key -> AuthHandler Request (Maybe User)

-- | This follows exactly the <a>Servant.OAuth2.Examples.Cookies</a>
--   example; we're using two providers because in the hard-coded `db.txt`
--   file I've set different roles for my own account with different
--   providers; you'll be able to edit that file to do the same.
data Routes mode
Routes :: (mode :- (AuthProtect "optional-cookie" :> NamedRoutes SiteRoutes)) -> (mode :- (AuthProtect Github :> ("auth" :> ("github" :> NamedRoutes (OAuth2Routes OAuth2Result))))) -> (mode :- (AuthProtect Google :> ("auth" :> ("google" :> NamedRoutes (OAuth2Routes OAuth2Result))))) -> Routes mode
[site] :: Routes mode -> mode :- (AuthProtect "optional-cookie" :> NamedRoutes SiteRoutes)
[authGithub] :: Routes mode -> mode :- (AuthProtect Github :> ("auth" :> ("github" :> NamedRoutes (OAuth2Routes OAuth2Result))))
[authGoogle] :: Routes mode -> mode :- (AuthProtect Google :> ("auth" :> ("google" :> NamedRoutes (OAuth2Routes OAuth2Result))))

-- | We now have a slightly more complicated route setup; we need our
--   homepage, and our admin area, which we will aim to protect with our
--   type-level tags; we also need a <a>logout</a> route, because it'll be
--   convenient for testing. This route will simply delete the present
--   cookie.
data SiteRoutes mode
SiteRoutes :: (mode :- Get '[HTML] Html) -> (mode :- ("admin" :> NamedRoutes AdminRoutes)) -> (mode :- ("logout" :> UVerb 'GET '[HTML] '[WithStatus 303 RedirectWithCookie])) -> SiteRoutes mode
[home] :: SiteRoutes mode -> mode :- Get '[HTML] Html
[admin] :: SiteRoutes mode -> mode :- ("admin" :> NamedRoutes AdminRoutes)
[logout] :: SiteRoutes mode -> mode :- ("logout" :> UVerb 'GET '[HTML] '[WithStatus 303 RedirectWithCookie])

-- | Nothing too innovative; we just pass off to respective handlers and
--   servers; in the <a>logout</a> route we set an empty cookie and
--   redirect home.
siteServer :: SiteRoutes (AsServerT PageM)

-- | Our admin routes. At this point they look normal.
data AdminRoutes mode
AdminRoutes :: (mode :- Get '[HTML] Html) -> AdminRoutes mode
[adminHome] :: AdminRoutes mode -> mode :- Get '[HTML] Html

-- | Here is where we introduce the <a>AdminPageM</a> type. Typically, a
--   handler like this would have type <a>Handler</a>; but here we're
--   denoting it as having the <a>AdminPageM</a> type. This means we can
--   call specific functions, that we will define below, such as
--   <a>getAdmin</a>. Importantly, we will see that we need to unwrap this
--   type (by verifying the current user!) before we can render this page.
adminHandler :: AdminPageM Html

-- | Here's the most important function. We aim to convert
--   <a>AdminPageM</a>s into <a>PageM</a>s. We do this in the context of an
--   <a>PageM</a> function, where we investigate the current user. If that
--   user is an admin (vi a<a>isAdmin</a>) then we convert the given
--   <a>AdminPageM</a> into a <a>PageM</a> by simply <a>coerce</a>ing it;
--   after all, the <a>Role</a> type was just a phantom type.
--   
--   If we fail to verify that they are an admin, we throw a http 404
--   error.
verifyAdmin :: ServerT (NamedRoutes AdminRoutes) AdminPageM -> ServerT (NamedRoutes AdminRoutes) PageM

-- | Note here that this function returns a server of <a>PageM</a>s; that's
--   because we pass the routes through the <a>verifyAdmin</a> function.
adminServer :: ServerT (NamedRoutes AdminRoutes) PageM

-- | A simple check to see if the user is present and has a <a>role</a>
--   that is equal to `"admin"`.
isAdmin :: Maybe User -> Bool

-- | Check if a user is present and therefore logged in.
isLoggedIn :: PageM Bool

-- | In the context of a <a>PageM</a>, maybe return the user; this is the
--   best we can do.
getUser :: PageM (Maybe User)

-- | In the present of an <a>AdminPageM</a>, <i>definitely</i> return a
--   user. We're happy with an error if this fails, because we know that a
--   user needs to be present.
--   
--   Note that it could be an extension to this code to eliminate the
--   <a>fromJust</a> here, and ensure that whatever context we're
--   referencing has eliminated the <a>Maybe</a> over the user.
--   
--   We leave this as an exercise for the reader :)
getAdmin :: AdminPageM User

-- | This time our home handler does a bit of busywork to show whether or
--   not you're logged in, and provide the relevant links. It also detects
--   if you're an admin, and if not, provides you a link to the admin page
--   anyway, to see if you can hack into it! :)
homeHandler :: PageM Html

-- | The final full server; we need a special <a>hoistServer</a> for the
--   <a>site</a> route, because we need to add the 'Maybe User' into the
--   <a>Env</a>. Otherwise, we just do as we've always done - pass off to
--   the <a>authServer</a>.
server :: Routes (AsServerT PageM)

-- | Our usual approach for <a>Github</a> settings.
mkGithubSettings :: Key -> OAuthConfig -> OAuth2Settings PageM Github OAuth2Result

-- | Our usual approach for <a>Google</a> settings.
mkGoogleSettings :: Key -> OAuthConfig -> OAuth2Settings PageM Google OAuth2Result

-- | Our usual approach to the <a>main</a> function; setting up the
--   settings, setting up the contexts for the relevant auth handler
--   functions.
main :: IO ()

-- | Utility function to load the hard-coded database.
loadDb :: IO Db
instance GHC.Show.Show Servant.OAuth2.Examples.Authorisation.User
instance GHC.Generics.Generic (Servant.OAuth2.Examples.Authorisation.AdminRoutes mode)
instance GHC.Generics.Generic (Servant.OAuth2.Examples.Authorisation.SiteRoutes mode)
instance GHC.Generics.Generic (Servant.OAuth2.Examples.Authorisation.Routes mode)


-- | This example follows the <a>Servant.OAuth2.Examples.Simple</a> example
--   very closely, but this time we use a configuration that let's enables
--   us to set a cookie, and then redirect to the homepage.
--   
--   Moreover, we set things up so that we can <i>read</i> that cookie on
--   <i>any</i> page, to determine if the current visitor is logged in.
--   
--   We will assume you have read the <a>Simple</a> example, and mostly
--   spend our time explaining what is different.
module Servant.OAuth2.Examples.Cookies

-- | This time our result type is a set of headers that both redirects, and
--   sets a particular cookie value. The cookie will, here, contain simply
--   the result of the oauth2 workflow; i.e. the users email.
type OAuth2Result = '[WithStatus 303 RedirectWithCookie]

-- | This is the corresponding handler for the above instance. Our
--   implementation is very simple, we just call
--   <a>getSessionIdFromCookie</a>, which is provided by the
--   <a>Servant.OAuth2</a> library itself; this decodes a
--   previously-encoded value from the cookie, by the corresponding
--   function <a>buildSessionCookie</a>, which we will later use through
--   the <a>simpleCookieOAuth2Settings</a> function.
optionalUserAuthHandler :: Key -> AuthHandler Request (Maybe Text)

-- | As last time, we have our routes; the main change is the inclusion of
--   the <a>AuthProtect</a> tag on the <a>home</a> route, that let's us
--   bring a potential user into scope for that page.
data Routes mode
Routes :: (mode :- (AuthProtect "optional-cookie" :> Get '[HTML] Html)) -> (mode :- (AuthProtect Github :> ("auth" :> ("github" :> NamedRoutes (OAuth2Routes OAuth2Result))))) -> Routes mode
[home] :: Routes mode -> mode :- (AuthProtect "optional-cookie" :> Get '[HTML] Html)
[auth] :: Routes mode -> mode :- (AuthProtect Github :> ("auth" :> ("github" :> NamedRoutes (OAuth2Routes OAuth2Result))))

-- | Again, we have settings, but this time, instead of using the
--   <a>defaultOAuth2Settings</a>, we use the
--   <a>simpleCookieOAuth2Settings</a> function to get default behaviour
--   that, upon successful completion of the oauth2 flow, builds a cookie
--   with a <i>session id</i> &amp;mdash; in this case just the ident of
--   the user &amp;mdash; and then redirects the browser to the homepage.
mkSettings :: Key -> OAuthConfig -> OAuth2Settings Handler Github OAuth2Result

-- | Now we can have a simple server implementation, but this time we can
--   check if the user us logged in by looking at the first parameter to
--   the <a>home</a> function; i.e. if it's <a>Nothing</a> then we're not
--   logged in, otherwise we are! Very convenient.
server :: OAuthConfig -> OAuth2Settings Handler Github OAuth2Result -> Routes (AsServerT Handler)

-- | Our entrypoint; the only addition here is that we need to obtain a
--   <a>Key</a> to do our cookie encryption/decryption; and we again need
--   to build up our context with our <a>Github</a>-based
--   <a>oauth2AuthHandler</a> and our own custom one,
--   <a>optionalUserAuthHandler</a>, to decode the cookie.
main :: IO ()
instance GHC.Generics.Generic (Servant.OAuth2.Examples.Cookies.Routes mode)


-- | This is the simplest example of a full application that makes use of
--   this library.
--   
--   We don't do anything with the result of successful authentication
--   other than return the ident that was provided to us. In an "real"
--   example, you'll want to set a cookie. For that, you can take a look at
--   <a>Servant.OAuth2.Examples.Cookies</a>.
--   
--   This file serves as a complete example; and you can read through this
--   documentation from top to bottom, in order to work out what each
--   component is.
module Servant.OAuth2.Examples.Simple

-- | First, we need to define an instance that corresponds to the result we
--   want to return. We're going with the <tt>basic</tt> option; so we'll
--   just take the Text value of the ident that comes back. Note that this
--   is a _list_ of potential return kinds; the reason it's set up this way
--   is only so we can explicitly say we'd like to return a 303 Redirect,
--   when using cookies.
type OAuth2Result = '[WithStatus 200 Text]

-- | Here we just define a very simple website, something like:
--   
--   <pre>
--   /
--   /auth/github/...
--   /auth/google/...
--   </pre>
--   
--   The <a>authGoogle</a> and <a>authGithub</a> routes will not be
--   implemented by us; they are both provided by a 'NamedRoutes
--   (OAuth2Routes OAuth2Result)' value; i.e. the routes themselves come
--   from <a>OAuth2</a>.
data Routes mode
Routes :: (mode :- Get '[HTML] Html) -> (mode :- (AuthProtect Github :> ("auth" :> ("github" :> NamedRoutes (OAuth2Routes OAuth2Result))))) -> (mode :- (AuthProtect Google :> ("auth" :> ("google" :> NamedRoutes (OAuth2Routes OAuth2Result))))) -> Routes mode
[home] :: Routes mode -> mode :- Get '[HTML] Html
[authGithub] :: Routes mode -> mode :- (AuthProtect Github :> ("auth" :> ("github" :> NamedRoutes (OAuth2Routes OAuth2Result))))
[authGoogle] :: Routes mode -> mode :- (AuthProtect Google :> ("auth" :> ("google" :> NamedRoutes (OAuth2Routes OAuth2Result))))

-- | We need to build an <a>OAuth2Settings</a> to pass to
--   <a>oauth2AuthHandler</a>, so that it knows which provider it is
--   working with. We also need to tag it with a <a>Handler</a>-like monad
--   that can interpret errors; in the simple case this is just the
--   <a>Handler</a> type itself, but in later examples (in particular the
--   <a>Servant.OAuth2.Examples.Authorisation</a> example) it will be a
--   custom monad.
mkGithubSettings :: OAuthConfig -> OAuth2Settings Handler Github OAuth2Result

-- | Exactly the same as <a>mkGithubSettings</a> but for the <a>Google</a>
--   provider.
mkGoogleSettings :: OAuthConfig -> OAuth2Settings Handler Google OAuth2Result

-- | Here we pull implement a very simple homepage, basically just showing
--   the links to login, and connecting the two <a>authGithub</a> and
--   <a>authGoogle</a> routes together. There's a bit of noise in passing
--   all the relevant configs in, but this would go away in a "real"
--   application, by passing that around in an env, or otherwise.
server :: Text -> OAuth2Settings Handler Github OAuth2Result -> Text -> OAuth2Settings Handler Google OAuth2Result -> Routes (AsServerT Handler)

-- | Entrypoint. The most important thing we do here is build our list of
--   contexts by calling <a>oauth2AuthHandler</a> with the respective
--   settings.
main :: IO ()
instance GHC.Generics.Generic (Servant.OAuth2.Examples.Simple.Routes mode)
